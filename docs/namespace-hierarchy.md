# メモリ階層構造の拡張計画

## 概要
- 目的: 単一の `namespace` 文字列でメモを切り分けている現状を拡張し、API キーによるユーザ分離と、プロジェクト単位の階層的な名前空間を実現する。
- コンセプト:
  - **ルート名前空間** = `chroot`。API キーごとに設定し、以降の相対移動ではこの範囲を越えられない。
  - **デフォルト名前空間** = `cd`。API キーごとに設定し、相対パスを展開するときの基点になる。
  - コマンド例: `A` → `projectA/DEF/A`, `../B` → `projectA/B`, `/C` → `projectA/C`。

## 要件整理
1. **ユーザ分離**
   - API キーでユーザを識別し、同一 DB 内でも完全独立運用。
   - ルート名前空間を API キーに紐づけ、他ユーザのデータは参照不能にする。
2. **プロジェクト切り分け**
   - ルート直下にプロジェクト（ドメイン）を配置し、デフォルト名前空間でサブプロジェクトに `cd` のように移動。
   - 相対パスによる名前空間切り替えを実装するが、ルートを越える `../` は禁止。
3. **名前空間一覧取得**
   - 現在の基点から `ls` 的にサブ名前空間を列挙する新ツール (`memory-list-namespaces`) を追加する。

## 影響範囲
- HTTP API（Cloudflare Workers）: API キー認証・名前空間解決・新ツール追加。
- データベース (Neon): `memory_entries` テーブル構造変更、API キーテーブル新設。
- STDIO アダプタ: API キーの設定項目追加、名前空間ツールの対応。
- ドキュメント: ルート/デフォルト名前空間の説明、クライアント設定例の更新。

## 技術設計
### 1. API キー管理
- 新テーブル `api_keys` を作成。
  - 主な列: `id`, `token_hash`, `owner_id`, `root_namespace`, `default_namespace`, `status`, `created_at`。
  - API キーはハッシュ化して保存。配布専用スクリプトで平文キーを生成。
- リクエスト受信時に `Authorization: Bearer <token>` または `X-API-Key` を必須化し、照合成功でリクエストコンテキストを作成。

### 2. データベース変更
- `memory_entries` に `owner_id` を追加し、ユニーク制約を `(owner_id, namespace, id)` に差し替え。
- 既存データは暫定オーナーに紐付けるマイグレーションを実行。
- インデックス: `owner_id, namespace`, `owner_id, namespace, id` などを追加して検索性能を維持。

### 3. 名前空間解決
- ルートとデフォルトを配列 (`rootSegments`, `defaultSegments`) で管理。
- 新ユーティリティ `resolveNamespace(input, context)` を実装。
  - 入力が空ならデフォルトを返す。
  - `/` から始まればルート配下の絶対パス。
  - `.` `..` を POSIX 的に解釈し、ルートより上への遷移はエラー。
  - 返却値は常に `root` プレフィックスを持つ正規化済み文字列。
- `memory.save/search/delete` では入力直後に `resolveNamespace` を通す。

### 4. メモリストアの改修
- `MemoryStore` のメソッドに `ownerId` を追加し、すべての SQL に `owner_id = $1` を含める。
- 返却する `namespace` は解決済み文字列。

### 5. 名前空間一覧ツール
- 新しい MCP ツール `memory-list-namespaces` を追加。
  - 入力: `prefix` (任意), `depth` (任意)。デフォルトで現在のデフォルト名前空間を基点とし、サブパスを列挙。
  - 出力: サブ名前空間のリスト（階層構造をフラットな配列で返し、クライアントで整形可能にする）。

### 6. STDIO アダプタ
- 新オプション `--memory-http-api-key` と環境変数 `MEMORY_HTTP_API_KEY` に対応。
- HTTP リクエストに `Authorization: Bearer` ヘッダーを付与。
- `memory-list-namespaces` をクライアント側にも登録し、結果を整形して出力。

### 7. ドキュメント更新
- `README.md` に階層化された名前空間の概念と API キー運用方法を追加。
- `docs/clients.md` などに環境変数例 (`MEMORY_HTTP_API_KEY`) や相対パスの使い方を追記。
- 運用者向けに API キー発行手順を記載したスクリプト/ドキュメントを追加。

## 実装ステップ
1. **DB マイグレーション**
   - `api_keys` テーブル作成、`memory_entries` に `owner_id` 追加、既存レコード紐付け。
2. **サーバ改修**
   - API キー検証ロジックと `RequestContext` 追加。
   - 名前空間解決ユーティリティ実装。
   - `memory.save/search/delete` を `ownerId` + 解決済み namespace で実行。
   - `memory.list_namespaces` エンドポイントを新設。
3. **STDIO/クライアント更新**
   - API キー設定オプション追加。
   - 新ツールを登録し、出力フォーマットを整形。
4. **テスト**
   - 名前空間解決の単体テスト（`.`/`..`/`../../` など）。
   - API キーによるアクセス制御のテスト。
   - `memory-list-namespaces` の挙動確認。
5. **ドキュメント整備**
   - 新仕様を README / docs 各所に反映。
   - API キー発行スクリプトと手順を追加。

## 開発上の留意点
- API キーはハッシュ化保存。平文は発行時のみ表示。
- 既存クライアントが一時的に API キーなしで利用している場合は後方互換用のフラグを検討（段階的リリース）。
- 名前空間の分割により SQL のフィルタ条件が増加するため、インデックス適用を確認する。
- `memory-list-namespaces` はレスポンス量を抑えるためページングや `depth` 制限を導入できるようにしておく。

## 次のアクション
- このドキュメントをリポジトリに追加後、上記ステップ 1（DB マイグレーション）から順に実装に着手する。
